---
description: Extremely concise summary of React's "You Might Not Need an Effect" — prefer render/data flow & handlers; use Effects only to sync with external systems.
globs:
  - "**/*.{tsx,jsx}"
  - "**/*.{ts,js}"
alwaysApply: false
---

# You Might Not Need an Effect

- **Principle:** Effects are an _escape hatch_—only use them to **synchronize with external systems** (DOM APIs, subscriptions, network). If no external system is involved, don't use an Effect.
- **Rule of thumb:** If it can be expressed via **props/state, render logic, or event handlers**, you probably **don't** need an Effect.

## Don't Use an Effect For

- Deriving/rendering data → compute during render; `useMemo` if expensive.
- User actions (POST/analytics on click) → do it in the event handler.
- Resetting/adjusting state on prop change → prefer `key` to reset; or derive during render.
- Sharing logic across events → extract a function and call it from handlers.
- Notifying parents/passing data up → call the parent's handler; lift state if needed.

## Do Use an Effect For

- Syncing with external systems: subscriptions (or `useSyncExternalStore`), imperative DOM, timers.
- Keeping network results synchronized with current inputs (if your framework doesn't provide a better data‑fetching primitive).

## Example

- **Don't:** `useEffect(() => setDerivedState(computeFromProps(prop)), [prop])` → **Do:** `const derivedState = computeFromProps(prop)` (compute during render).
- **Don't:** `useEffect(() => { if (isSubmitting) { analytics.track('submit') } }, [isSubmitting])` → **Do:** Call `analytics.track('submit')` in the submit button's `onClick` handler.
